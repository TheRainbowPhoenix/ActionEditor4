# ACTIONEDITOR4 EDITOR GUIDE
I focus on the editor directory. Everything else is legacy and noise. The package name is editor/acted4. Python files matter. Qt Designer ui xml and generated ui_*.py stubs are designer territory. Leave them alone. Same for svg assets. The bindings directory is future work. Ignore it. When in need for user context, check the root help/en/*.md files for user documentation.

The entry point for the desktop editor is editor/main.py. Run it with `python main.py` from inside the editor folder after installing PySide6 from requirements.txt. The app boots a QApplication, pushes the native theme through ThemeManager, shows the project picker with ProjectManager, then opens the main window via WindowManager. The event loop keeps running while WindowManager reports at least one visible window. WindowManager swaps between the main window and auxiliary top level windows like the world map editor.

Global app state lives under editor/acted4/common. AppStateManager exposes the palette mode enum so every dock or dialog can stay in sync with the current layer. Configuration wraps QSettings in config.py to track recent projects and normalize paths. Message boxes use AutoDismissDialog in message_box.py as a thin wrapper around QMessageBox so you can call show_info and dismiss during long loads. ProjectManager glues the QuickStart dialog, project load, and project copy logic together. WindowManager tracks the current QMainWindow and lets you swap what is considered the main window.

The core package holds the primary windows. core/main_window.py builds the main editor frame using Ui_MainWindow generated from Qt Designer. It wires menu actions to stub handlers. Palette actions go through AppStateManager and share an exclusive QActionGroup. Dock creation is centralized in init_docks. Recent stages read from QSettings and use placeholder stubs for actual loading. File open and project open flow through ProjectManager and spawn new MainWindow instances through WindowManager. Most command handlers are intentionally empty and wait for implementation. core/world_window.py implements the world map editor window with its own MapViewport widget. It manages edit modes, tile placement, block selection, and coordinates display. The chip picker window lives in dialogs/world/chip_picker.py and feeds tile selection back to the world window. core/project.py defines ProjectRequirements, enumerates required and optional files, and owns ProjectData. try_load validates folder structure, reports with AutoDismissDialog, parses required System.dat and GValInfo.dat, then iterates optional files with data classes defined in data/files.py. ProjectStatus in core/project_status.py keeps track of file presence and parse success.

Data parsing lives in editor/acted4/data. ActedBinaryFile in binary_file.py reads and writes little endian data with manual cursor management and Shift JIS strings. files.py contains dataclasses describing every parsed resource: animations, sprite definitions, sound assets, screen effects, world map tiles, events, and more. Each class inherits from ActedBinaryFile and implements parse and save methods to map the legacy binary layout. These structures are still evolving. Expect gaps and TODO comments while the reverse engineering continues.

Dialogs sit in editor/acted4/dialogs. quickstart.py implements the startup project picker with a recent projects list that persists through QSettings. The database subpackage is a large collection of modal tabs that edit the various data files. database/database.py builds the tabbed dialog and instantiates tab classes for animation sets, animations, character specific graphics, sword types, effects, pictures, sound, and BGM. Each tab inherits from BaseTabDialog or SideListTabDialog in database/base_dialog.py to share list handling helpers, dirty state tracking, and apply logic. The world subpackage currently contains the chip picker and placeholder world map settings dialog. When adding dialogs create or modify the Python controller only. Ui files and ui_*.py stubs are designer generated and should stay untouched by developers.

Resources live under editor/acted4/resources. Fonts contains Anonymous Pro and Inconsolata for console like widgets. resources.qrc and the compiled resources_rc.py map icons and fonts into Qt. icons sit under resources/img/icons. Themes are supposed to live in resources/themes each with a style.qss consumed by ThemeManager.apply_theme. Right now only the native theme is available. resources/python/acted4.py is a placeholder command provider for future scripting support.

Project data flows through a pile of binary files. Check help/en for functional documentation extracted from the original Japanese manual. commando.md explains how commands work. menu_project_database.md and menu_stage_set.md mirror what each main window menu entry is supposed to do. The Stage4 WiP2 hexpat file under patterns maps part of the level format. patterns/data holds partial binary templates used while reverse engineering. Use these references when implementing parse or save routines.

When you need a project to open the editor, make sure the folder matches ProjectRequirements. You need a data directory with System.dat and GValInfo.dat at minimum. Optional files improve features. For example WorldMap.dat enables the world window. QuickStart.validate_project_directory currently checks for data/GValInfo.dat and data/System.dat only. ProjectManager.save_project_as creates the required folders, copies known files, then reloads from the new path.

The main window uses floating dock widgets. There are palette modes for blocks, characters, and items controlled through AppStateManager. Each palette mode is expected to spawn different side windows and toolbars in the future. The stage view currently lacks implementation. Expect to coordinate with MapViewport like the world window does once the stage scene is ported.

For testing run python main.py from the editor root. PySide6 is the only runtime dependency right now. There is no automated test suite yet. Manual regression through dialogs is the norm. Keep an eye on print statements and stub methods that still need real logic. Implementations should always update the relevant data classes and set dirty flags so the parent dialog knows when to save.

Coding conventions: stay in snake_case for methods and attributes. Use dataclasses for structured binary data. Use QSettings for persistent editor preferences. Keep business logic inside Python files under acted4. Keep UI layout in Qt Designer files. No not alter designer files. When needing a new designer file, fire a request to the designer. Don't alter resources.qrc. Don't re-generate ui.

Before changing anything read TODO.md and tasks.md inside the editor directory for pending work. Root folder help/en holds guide references for UI layout from the original tool. The translations folder currently stores string lists to help future localization. The plugins folder is empty and reserved for third party extensions.

This codebase is mid port and full of placeholders. Expect stubbed menu entries, incomplete parse routines, and missing dialogs. Coordinate with reverse engineering notes under patterns when expanding the data layer. Always verify binary read offsets against existing hex patterns. Use AutoDismissDialog for user feedback during long operations. Update ProjectStatus when you add new required or optional files so loading continues to report correctly. Remember that WindowManager closes the previous window when you open a new one. Set bypass_close_check if you need to avoid shutdown prompts when swapping windows programmatically.

Be sure to check existing code structure and match the coding style and architecture of dialogs and UI elements before adding anything. 